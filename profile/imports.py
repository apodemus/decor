"""
Functions that extract all the import statements from python source code
"""

import ast
import sys
from io import StringIO

from recipes.io import read_file_slice
from decor.profile import HLineProfiler
from decor.profile.printers import ShowHistogram


class ImportExtractor(ast.NodeVisitor):
    """
    Extract, re-construct and buffer import statements from parsed python source code
    """
    def __init__(self):
        self.buffer = StringIO()
        self.nr_alias = 1
        self.current_nr = 1

    def visit_Import(self, node):
        self.buffer.write('import ')
        self.current_nr = 1
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        self.buffer.write('from %s%s import ' % ('.'*node.level, node.module or ''))
        self.nr_alias = len(node.names)
        self.current_nr = 1
        self.generic_visit(node)

    def visit_alias(self, node):
        self.buffer.write(node.name)
        if node.asname:
            self.buffer.write(' as %s' % node.asname)
        char = [', ', '\n'][self.current_nr == self.nr_alias]
        self.buffer.write(char)
        self.current_nr += 1


class ModuleExtractor(ast.NodeVisitor):
    """
    Extract names of imported (external) modules
    """
    def __init__(self):
        self.modules = []
        self.accept = True

    def visit_Import(self, node):
        self.accept = True
        # print(ast.dump(node), self.accept)
        self.generic_visit(node)

    def visit_ImportFrom(self, node):
        self.accept = not bool(node.level)
        # print(ast.dump(node), self.accept)
        self.generic_visit(node)

    def visit_alias(self, node):
        # print(ast.dump(node), self.accept)
        if self.accept:
            self.modules.append(node.name)
            # self.generic_visit(node)


def get_block(filename, up_to_line):
    """"""
    lines = read_file_slice(filename, up_to_line)
    # NOTE: partial code blocks lead to `SyntaxError: unexpected EOF while parsing`
    if len(lines) and lines[-1].startswith(''*4):
        # only go up to nearest un-indented line above `up_to_line`
        lines = lines[:-lines[::-1].index('\n')]
    # could also try: `inspect.getblock(lines)` though this would limit us to imports from first
    # code block only
    content = '\n'.join(lines)
    return content


def depends_on(filename, up_to_line=None):
    code = get_block(filename, up_to_line)
    tree = ast.parse(code)
    visitor = ModuleExtractor()
    visitor.visit(tree)
    return visitor.modules


def extractor(filename, up_to_line=None):
    """
    Tokenizer that extracts all the import statements from python source code file

    :param filename: The source code file - example.py
    :param up_to_line: Maximal search depth (line nr) in source code file
    :return: str block of import statements
    """
    code = get_block(filename, up_to_line)
    tree = ast.parse(code)
    iv = ImportExtractor()
    iv.visit(tree)
    iv.buffer.seek(0)
    imports = iv.buffer.read()
    return imports


class ShowDynamicFunction(ShowHistogram):
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    def __init__(self, contents, timings, unit):
        self._contents = contents
        super().__init__(timings, unit)

    def get_block(self, filename, start_lineno, strip='\n\r'):
        if filename == '<string>':
            # function generated by exec?
            return self._contents
        else:
            return super().get_block(filename, start_lineno)

    def preamble(self, filename, func_name, stream=None):
        """print preamble"""
        self._preamble = stream = StringIO()
        stream.write("File: %s\n" % '__main__')
        stream.write("Function: %s\n" % func_name)
        stream.write("Total time: %g s\n" % self.total_time)


class ImportProfiler(HLineProfiler):
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    def print_stats(self, content={}):
        lstats = self.get_stats()
        stats = lstats.timings
        unit = lstats.unit

        fdict = {func.__name__: func for func in self.functions}
        # NOTE: will only work for unique function names

        for (fn, lineno, name), timings in sorted(stats.items()):
            # docstring = getattr(fdict[name], '__doc__', None)
            fcontent = content.get(name)
            show = ShowDynamicFunction(fcontent, timings, unit)

            show(fn, lineno, name,
                 # strip_docstring=True
                 # docstring=docstring,
                 condense=True,
                 truncate_lines=80)

            # class HistogramDisplay(ProfileStatsDisplay):
            # profiler_class = HLineProfiler


if __name__ == '__main__':
    filename = sys.argv[1]
    maxLines = 100

    # extract all import statements up to maxLines
    imports = extractor(filename, maxLines)
    importLines = imports.split('\n')
    importLines = ['def importer():'] + importLines
    body = '\n\t'.join(importLines).expandtabs()

    # create the function object from extracted source code str
    exec(body)
    linelist = body.split('\n')
    content = {'importer': linelist}

    # setup profiler
    profiler = ImportProfiler()
    profiler.add_function(importer)
    profiler.enable_by_count()

    # run the dynamically generated function
    importer()
    profiler.print_stats(content)
